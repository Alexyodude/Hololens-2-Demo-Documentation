{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Wecome to Hololens 2 Demo Documention","text":"<p>The documentation contains information to replicate the project. It has the hierarchy and thought process of what the components attached to the objects are meant to do.</p> <p>The site can be shared easily with this tinyurl \"https://tinyurl.com/Holo2Demo\".</p>"},{"location":"Unity/Component/","title":"Component","text":"<p>A component is something that is attached to the a object. A Script is a type of component.</p>"},{"location":"Unity/Empty%20Object/","title":"Empty Object","text":"<p>An empty object contains no mesh of any sort and is primarily used for organisational purpose such as being a parent of some hierarchy.  </p>"},{"location":"Unity/GameObject/","title":"Gameobject","text":"<p>A GameObject the most basic ways to describe objects in the scene. Every object in the scene is a GameObject so it is the most encompassing category.</p>"},{"location":"Unity/Occlusion/","title":"Occlusion","text":"<p>Occlusion is a display setting that sets meshes to be invisible yet still provide a physical collision with other objects.</p>"},{"location":"Unity/Prefab/","title":"Prefab","text":"<p>A prefab is a blueprint object, this means that when editing this object the changes will be applied to every instance of this object being used elsewhere.</p> <p>The use of this capability is an efficient way to make changes across the entire project without having to make repetitive manual changes across objects.</p>"},{"location":"Unity/Script/","title":"Script","text":"<p>A script is programmed in C# and it can control the state of the game from the game.</p>"},{"location":"Unity/Setting%20Up%20the%20Enviorment/","title":"Setting Up The Enviorment","text":"<p>Download Unity and install the lts (latest) version of the game engine. make sure to select universal UWP(windows platform) and windows when downloading the version.</p> <p>Follow the tutorial below: XR Step-by-Step 2023! Hololens 2: Setting up your Project in Unity 2022 + MRTK 2.8.3 + Visual Studio 2022 \u2013 Lance Larsen \u2013 Microsoft MVP \u2013 Hololens / VR / AR</p> <p>Then connect to the Hololens 2 remotely by going in the unity project then Mixed Reality &gt; Remoting &gt; Holographic Remoting for Play Mode.</p> <p>Inside the Hololens 2 open the App named \"Holographic Remoting\". Type the ip address seen inside the app into the settings inside \"Holographic Remoting for Play Mode\" in the unity project. Leave the port as is and make sure to press \"enable holographic remoting for play mode\". </p> <p>This should setup the Hololens 2 to be play tested. </p> <p>The current project features and improvements are described in Version.  </p>"},{"location":"Unity/Version/","title":"Version","text":""},{"location":"Unity/Version/#possible-ideas-to-improve","title":"Possible Ideas to Improve","text":"<ul> <li>Upgrade Random Movement script to a neural ai script that navigates the world intelligently</li> <li>Upgrade Drone Boid script to an ai script that targets enemies better and follows the user input smoothly</li> <li>Include a minimap for the user, which conveys key information about the surrounding environment in a clear and simple format</li> <li>Physical external input from a device such as a model gun to improve experience and immersion</li> </ul>"},{"location":"Unity/Version/#version-01","title":"Version 0.1","text":"<ul> <li> <p>UI with toggle and press buttons:</p> <ul> <li>Create Box</li> <li>Toggle Enemy</li> <li>Toggle Drone</li> <li>Toggle Pistol</li> <li>Toggle Mesh</li> </ul> </li> <li> <p>Box creation and destruction based on set boundary</p> </li> <li>Enemies and drones are set before as public variables so it is constant</li> <li>Enemies spawn randomly on meshes with a normal vector roughly pointing up</li> <li> <p>Enemies move in straight lines unless it collides with a mesh (Random Movement)</p> <ul> <li>Colliding results in a random direction to be selected</li> <li>Enemies respawn if they leave the set boundary</li> <li>Custom tag \"Enemy\" selected to differentiate object when collision is detected with another object</li> </ul> </li> <li> <p>Drones move towards the user's ray pointer</p> <ul> <li>Separation between the drones are provided by Drone Boid script</li> <li>Custom tag \"Destroy\" selected to differentiate object when collision is detected with another object</li> </ul> </li> <li> <p>Mesh visibility changes between visible and Occlusion</p> </li> <li> <p>The pistol's relative position and orientation is used to instantiate the bullet</p> <ul> <li>Bullet has custom tag \"Destroy\" selected for enemy and weapon collision logic</li> </ul> </li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Boid/","title":"Drone Boid","text":""},{"location":"Unity/Drone%20Scripts/Drone%20Boid/#summary","title":"Summary","text":"<ul> <li>Complex Behaviour: The <code>DroneBoid</code> class integrates complex behaviours like separation, cohesion, alignment, and following user inputs, demonstrating an advanced use of Unity's physics and Mixed Reality Toolkit's input system.</li> <li>Performance Considerations: The script uses potentially expensive operations such as searching for objects by tag and frequent vector calculations, which might impact performance in a large-scale application.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Boid/#droneboid-class-explanation","title":"<code>DroneBoid</code> Class Explanation","text":""},{"location":"Unity/Drone%20Scripts/Drone%20Boid/#namespaces","title":"Namespaces","text":"<ul> <li><code>using UnityEngine;</code>: Provides access to Unity's core classes and functionalities.</li> <li><code>using Microsoft.MixedReality.Toolkit.Input;</code>: Provides access to Mixed Reality Toolkit's input functionalities, used to track user interactions through various pointers.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Boid/#class-definition","title":"Class Definition","text":"<pre><code>public class DroneBoid : MonoBehaviour\n</code></pre> <ul> <li><code>public class DroneBoid</code>: Defines a class named <code>DroneBoid</code>.</li> <li><code>: MonoBehaviour</code>: Inherits from <code>MonoBehaviour</code>, allowing this class to be attached to Unity GameObjects and utilize Unity's lifecycle methods like <code>Start</code> and <code>Update</code>.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Boid/#variables","title":"Variables","text":"<ul> <li>Public floats (<code>maxSpeed</code>, <code>maxForce</code>, etc.): Define the behaviour limits and radii for boid operations, such as speed, force, and distances for neighbour interactions.</li> <li>Private <code>Vector3</code> variables (<code>velocity</code>, <code>acceleration</code>): Used to calculate and apply movement physics.</li> <li>Private <code>Rigidbody</code> (<code>rb</code>): The physics component used to apply forces for movement.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Boid/#start-method","title":"<code>Start</code> Method","text":"<pre><code>void Start()\n{\n    velocity = Random.insideUnitSphere * maxSpeed;\n    rb = GetComponent&lt;Rigidbody&gt;();\n\n    if (rb == null)\n    {\n        Debug.LogError(\"Rigidbody component not found on this GameObject\");\n    }\n}\n</code></pre> <ul> <li> <p>Initialization:</p> <ul> <li><code>velocity</code>: Initializes with a random direction and magnitude limited by <code>maxSpeed</code>.</li> <li><code>rb</code>: Attempts to retrieve the <code>Rigidbody</code> component attached to the same GameObject.</li> <li> <p>Error Handling:</p> </li> <li> <p>Checks if <code>rb</code> is not null to ensure the script will function properly, logging an error if the component is missing.</p> </li> </ul> </li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Boid/#update-method","title":"<code>Update</code> Method","text":"<pre><code>void Update()\n{\n    List&lt;GameObject&gt; drones = new List&lt;GameObject&gt;(GameObject.FindGameObjectsWithTag(\"Destroy\"));\n\n    Vector3 separation = Separate(drones);\n    Vector3 cohesion = Cohere(drones);\n    Vector3 alignment = Align(drones);\n    Vector3 userFollow = FollowUser();\n\n    separation *= 2.0f;\n    cohesion *= 1.0f;\n    alignment *= 1.0f;\n    userFollow *= 1.5f;\n\n    acceleration = separation + cohesion + alignment + userFollow;\n    velocity += acceleration * Time.deltaTime;\n    velocity = Vector3.ClampMagnitude(velocity, maxSpeed);\n\n    ApplyForce(velocity);\n\n    if (velocity.sqrMagnitude &gt; 0.01f)\n    {\n        transform.rotation = Quaternion.LookRotation(velocity);\n    }\n}\n</code></pre> <ul> <li>Dynamic Behavior:<ul> <li>Boid Functions: Calculates forces from separate, cohesion, alignment, and user follow behaviors.</li> <li>Force Application: Accumulates forces into <code>acceleration</code>, modifies <code>velocity</code>, and applies it via <code>ApplyForce</code>.</li> </ul> </li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Boid/#boid-behaviors-methods-like-separate-cohere-align-seek","title":"Boid Behaviors (Methods like <code>Separate</code>, <code>Cohere</code>, <code>Align</code>, <code>Seek</code>)","text":"<ul> <li>Purpose: Each function implements part of the boid flocking algorithm:<ul> <li><code>Separate</code>: Avoids crowding by maintaining a minimum distance between each drone.</li> <li><code>Cohere</code>: Moves towards the average position of nearby drones to stay together.</li> <li><code>Align</code>: Aligns velocity with nearby drones to match their speed and direction.</li> <li><code>Seek</code>: Steers towards a target position.</li> </ul> </li> <li>Implementation:<ul> <li>Each function calculates a steering force based on the boids' current positions and velocities, and these forces are combined to determine the drone's movement each frame.</li> </ul> </li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Boid/#followuser-method","title":"<code>FollowUser</code> Method","text":"<pre><code>Vector3 FollowUser()\n{\n    var pointers = PointerUtils.GetPointers&lt;IMixedRealityPointer&gt;();\n    foreach (var pointer in pointers)\n    {\n        if (pointer.Controller != null &amp;&amp; pointer.IsInteractionEnabled)\n        {\n            Vector3 seekForce = Seek(pointer.Result.Details.Point);\n\n            if (IsNaN(seekForce)) seekForce = Vector3.zero;\n\n            return seekForce;\n        }\n    }\n    return Vector3.zero;\n}\n</code></pre> <ul> <li>User Interaction:<ul> <li>Tracks user input through Mixed Reality Toolkit's pointers and guides the drone towards the pointed location.</li> </ul> </li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Boid/#utility-functions-applyforce-isnan","title":"Utility Functions (<code>ApplyForce</code>, <code>IsNaN</code>)","text":"<ul> <li><code>ApplyForce</code>: Applies a force to the drone's <code>Rigidbody</code>, considering physics.</li> <li><code>IsNaN</code>: Checks if a vector contains invalid (NaN) values to prevent errors in physics calculations.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Child%20Collision%20Handler/","title":"Drone Child Collision Handler","text":""},{"location":"Unity/Drone%20Scripts/Drone%20Child%20Collision%20Handler/#summary","title":"Summary","text":"<p>The <code>DroneChildCollisionHandler</code> is an efficient way to handle collisions for parts of a composite object (like a drone) where individual components may not need to process collisions independently, but rather report them to a central handler. This setup simplifies the management of complex interactions by encapsulating collision handling logic within the parent object, reducing redundancy and maintaining cleaner code architecture.</p>"},{"location":"Unity/Drone%20Scripts/Drone%20Child%20Collision%20Handler/#dronechildcollisionhandler-class-explanation","title":"<code>DroneChildCollisionHandler</code> Class Explanation","text":""},{"location":"Unity/Drone%20Scripts/Drone%20Child%20Collision%20Handler/#namespace","title":"Namespace","text":"<pre><code>using UnityEngine;\n</code></pre> <p><code>UnityEngine</code>: Provides classes and methods necessary for scripting in Unity, including components, game objects, and system events like collisions.</p>"},{"location":"Unity/Drone%20Scripts/Drone%20Child%20Collision%20Handler/#class-definition","title":"Class Definition","text":"<pre><code>public class DroneChildCollisionHandler : MonoBehaviour\n</code></pre> <ul> <li><code>public class DroneChildCollisionHandler</code>: Declares a public class named <code>DroneChildCollisionHandler</code>.</li> <li><code>: MonoBehaviour</code>: Indicates that <code>DroneChildCollisionHandler</code> inherits from <code>MonoBehaviour</code>, allowing it to be attached to GameObjects and use Unity's event system.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Child%20Collision%20Handler/#fields","title":"Fields","text":"<ul> <li><code>private DroneParentCollisionHandler parentHandler;</code>: A private field that stores a reference to the <code>DroneParentCollisionHandler</code>. This reference is used to pass collision information from the child to the parent.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Child%20Collision%20Handler/#methods","title":"Methods","text":""},{"location":"Unity/Drone%20Scripts/Drone%20Child%20Collision%20Handler/#start-method","title":"<code>Start</code> Method","text":"<pre><code>void Start()\n{\n    // Get the parent handler\n    parentHandler = GetComponentInParent&lt;DroneParentCollisionHandler&gt;();\n}\n</code></pre> <ul> <li>Purpose: Called before the first frame update, this method initializes the <code>parentHandler</code> by finding the <code>DroneParentCollisionHandler</code> component on the parent GameObject.</li> <li><code>GetComponentInParent&lt;T&gt;()</code>: Retrieves the component of the specified type from the parent GameObject. This is used here to ensure that any collision on the child is managed by a centralized handler on the parent.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Child%20Collision%20Handler/#oncollisionenter-method","title":"<code>OnCollisionEnter</code> Method","text":"<pre><code>void OnCollisionEnter(Collision collision)\n{\n    Debug.Log(\"DroneBoop\");\n    // Relay the collision to the parent handler\n    if (parentHandler != null)\n    {\n        parentHandler.HandleChildCollision(collision);\n    }\n}\n</code></pre> <ul> <li>Purpose: Automatically called by Unity when the GameObject this script is attached to collides with another GameObject.</li> <li>Functionality:<ul> <li>Logging: Outputs a log message (\"DroneBoop\") to the console to indicate a collision has occurred.</li> <li>Collision Handling: If <code>parentHandler</code> is not null (i.e., it has been successfully linked in <code>Start</code>), the collision event is forwarded to the parent handler via the <code>HandleChildCollision</code> method. This allows for centralized processing of collisions at the parent level.</li> <li></li> </ul> </li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Parent%20Collision%20Handler/","title":"Drone Parent Collision Handler","text":""},{"location":"Unity/Drone%20Scripts/Drone%20Parent%20Collision%20Handler/#summary","title":"Summary","text":"<p>The <code>DroneParentCollisionHandler</code> class provides a comprehensive mechanism for dealing with collisions both directly and indirectly (via child components) for drone objects in a game. It ensures that any significant collision results in appropriate actions, such as the destruction of the drone, centralizing collision handling logic in the parent component for easier maintenance and modification.</p>"},{"location":"Unity/Drone%20Scripts/Drone%20Parent%20Collision%20Handler/#droneparentcollisionhandler-class-explanation","title":"<code>DroneParentCollisionHandler</code> Class Explanation","text":""},{"location":"Unity/Drone%20Scripts/Drone%20Parent%20Collision%20Handler/#namespace","title":"Namespace","text":"<pre><code>using UnityEngine;\n</code></pre> <ul> <li><code>UnityEngine</code>: Provides classes and methods necessary for scripting in Unity, including components, game objects, and system events like collisions.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Parent%20Collision%20Handler/#class-definition","title":"Class Definition","text":"<pre><code>public class DroneParentCollisionHandler : MonoBehaviour\n</code></pre> <ul> <li><code>public class DroneParentCollisionHandler</code>: Declares a public class named <code>DroneParentCollisionHandler</code>.</li> <li><code>: MonoBehaviour</code>: Indicates that <code>DroneParentCollisionHandler</code> inherits from <code>MonoBehaviour</code>, allowing it to be attached to GameObjects and utilize Unity's event system.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Parent%20Collision%20Handler/#fields","title":"Fields","text":"<ul> <li><code>private ToggleDrone droneManager;</code>: A private field that stores a reference to the <code>ToggleDrone</code> component. This component presumably manages the broader aspects of drone functionality, including possibly creating and destroying drone instances.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Parent%20Collision%20Handler/#methods","title":"Methods","text":""},{"location":"Unity/Drone%20Scripts/Drone%20Parent%20Collision%20Handler/#start-method","title":"<code>Start</code> Method","text":"<pre><code>void Start()\n{\n    droneManager = GetComponentInParent&lt;ToggleDrone&gt;();\n    //droneManager.droneDestroy(gameObject);\n}\n</code></pre> <ul> <li>Purpose: Initializes the <code>droneManager</code> by retrieving the <code>ToggleDrone</code> component from the parent GameObject. This setup assumes that the drone behavior is managed centrally by the <code>ToggleDrone</code> script.</li> <li>Initialization: The commented line <code>droneManager.droneDestroy(gameObject);</code> suggests that there might be conditions under which the parent drone should be destroyed immediately upon initialization, but it is commented out to likely remain inactive until specific conditions are met.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Parent%20Collision%20Handler/#handlechildcollision-method","title":"<code>HandleChildCollision</code> Method","text":"<pre><code>public void HandleChildCollision(Collision collision)\n{\n    Debug.Log(\"DroneParent\");\n    // Check if the collided object has the tag \"Enemy\" or \"Destroy\"\n    if (collision.gameObject.CompareTag(\"Enemy\") || collision.gameObject.CompareTag(\"Destroy\"))\n    {\n        droneManager.droneDestroy(gameObject);\n    }\n}\n</code></pre> <ul> <li>Purpose: This method is called by child components (via <code>DroneChildCollisionHandler</code>). It processes collisions involving child components by determining if any action should be taken, such as destroying the drone.</li> <li>Functionality:<ul> <li>Logs a message \"DroneParent\" to indicate that a collision has been handled at the parent level.</li> <li>Checks if the collision involves an object tagged as \"Enemy\" or \"Destroy\". If so, it triggers destruction of the parent drone via the <code>droneDestroy</code> method on <code>droneManager</code>.</li> </ul> </li> </ul>"},{"location":"Unity/Drone%20Scripts/Drone%20Parent%20Collision%20Handler/#oncollisionenter-method","title":"<code>OnCollisionEnter</code> Method","text":"<pre><code>private void OnCollisionEnter(Collision collision)\n{\n    Debug.Log(\"DroneParentBox\");\n    // Check if the collided object has the tag \"Enemy\"\n    if (collision.gameObject.CompareTag(\"Enemy\"))\n    {\n        droneManager.droneDestroy(gameObject);\n    }\n}\n</code></pre> <ul> <li>Purpose: Directly handles collisions encountered by the parent drone itself, not just those relayed by children.</li> <li>Functionality:<ul> <li>Logs \"DroneParentBox\" to differentiate from collisions handled due to child components.</li> <li>Similar to <code>HandleChildCollision</code>, it checks for collisions with objects tagged \"Enemy\" and destroys the drone if such a collision occurs.</li> </ul> </li> </ul>"},{"location":"Unity/Drone%20Scripts/Toggle%20Drone/","title":"Toggle Drone","text":""},{"location":"Unity/Drone%20Scripts/Toggle%20Drone/#summary","title":"Summary","text":"<ul> <li>Drone Management: The class allows for activating and deactivating drones, which follow the user within certain conditions.</li> <li>Explosion Handling: It includes functionality to handle drone destruction, complete with an explosion effect.</li> <li>Dynamic Interaction: The drones dynamically adjust their positions relative to the user during gameplay.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Toggle%20Drone/#toggledrone-class-explanation","title":"<code>ToggleDrone</code> Class Explanation","text":""},{"location":"Unity/Drone%20Scripts/Toggle%20Drone/#namespaces","title":"Namespaces","text":"<pre><code>using System;\nusing System.Collections.Generic;\nusing UnityEngine;\n</code></pre> <ul> <li><code>using System;</code>: Provides basic data types and functionalities.</li> <li><code>using System.Collections.Generic;</code>: Provides access to generic collections like <code>List</code>.</li> <li><code>using UnityEngine;</code>: Provides access to Unity-specific classes and methods.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Toggle%20Drone/#class-definition","title":"Class Definition","text":"<pre><code>public class ToggleDrone : MonoBehaviour\n</code></pre> <ul> <li><code>public</code>: Makes the class accessible from other scripts and visible in Unity's Inspector.</li> <li><code>class ToggleDrone</code>: Defines a class named <code>ToggleDrone</code>.</li> <li><code>: MonoBehaviour</code>: Inherits from <code>MonoBehaviour</code>, allowing the script to be attached to Unity GameObjects and access Unity lifecycle methods like <code>Start</code> and <code>Update</code>.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Toggle%20Drone/#variables","title":"Variables","text":"<ul> <li><code>public GameObject explosion;</code>: Reference to the explosion prefab that will be instantiated when a drone is destroyed.</li> <li><code>public GameObject DronePrefab;</code>: Reference to the drone prefab that will be instantiated in the scene.</li> <li><code>public GameObject user;</code>: Reference to the user (likely the player or a central object) that the drones will follow.</li> <li><code>private List&lt;GameObject&gt; Drones = new List&lt;GameObject&gt;();</code>: A list to keep track of the instantiated drone GameObjects.</li> <li><code>public int numDrone = 10;</code>: Number of drones to spawn when drones are activated.</li> <li><code>Boolean isDrone = false;</code>: A flag to determine whether drones are currently active or not.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Toggle%20Drone/#update-method","title":"<code>Update</code> Method","text":"<pre><code>private void Update()\n{\n    if (isDrone)\n    foreach (GameObject drone in Drones)\n    {\n        if (drone != null)\n        {\n            if (Vector3.Distance(drone.transform.position, user.transform.position) &gt; 4 || drone.transform.position.y &lt; -0.2)\n            {\n                drone.transform.position = Vector3.MoveTowards(drone.transform.position, user.transform.position, 0.1f);\n            }\n        }\n    }\n}\n</code></pre> <ul> <li>Purpose: Continuously checks the state of drones and updates their positions to move them towards the user.</li> <li>Drone Movement:<ul> <li>The drones move towards the user's position if they are too far (more than 4 units away) or if they are below a certain Y-axis threshold (<code>y &lt; -0.2</code>).</li> <li>The drones move with a speed of <code>0.1f</code> units per frame.</li> </ul> </li> <li><code>isDrone</code>: Only checks and moves drones if <code>isDrone</code> is <code>true</code>.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Toggle%20Drone/#ondrone-method","title":"<code>OnDrone</code> Method","text":"<pre><code>public void OffDrone()\n{\n    foreach (GameObject drone in Drones)\n    { \n        Destroy(drone); \n    }\n    Drones.Clear();\n    isDrone = false;\n}\n</code></pre> <ul> <li>Purpose: Deactivates all active drones and clears the <code>Drones</code> list.</li> <li>Drone Removal:<ul> <li>Iterates through the <code>Drones</code> list, destroying each drone GameObject.</li> <li>Clears the <code>Drones</code> list to remove all references to the destroyed drones.</li> </ul> </li> <li><code>isDrone</code>: Sets the flag to <code>false</code> to indicate that drones are no longer active.</li> </ul>"},{"location":"Unity/Drone%20Scripts/Toggle%20Drone/#dronedestroy-method","title":"<code>droneDestroy</code> Method","text":"<pre><code>public void droneDestroy(GameObject drone)\n{\n    Destroy(Instantiate(explosion, drone.transform.position, Quaternion.identity), 2f);\n    drone.transform.position = user.transform.position + user.transform.forward * 0.5f;\n}\n</code></pre> <ul> <li>Purpose: Handles the destruction of a specific drone, including triggering an explosion effect.</li> <li>Explosion Effect:<ul> <li>Instantiates an explosion prefab at the drone's position.</li> <li>The explosion is automatically destroyed after 2 seconds to clean up the scene.</li> </ul> </li> <li>Drone Position Reset:<ul> <li>After triggering the explosion, the drone's position is reset to a point slightly in front of the user (<code>0.5f</code> units in the direction the user is facing).</li> </ul> </li> </ul>"},{"location":"Unity/Enemy%20Scripts/Animator/","title":"Animator","text":"<p>Used the \"StarterAssetsThirdPerson\" Controller and used \"Terrorist_LiteAvatar\" for the Avatar.</p> <p></p> <p>More animator can be found here.</p>"},{"location":"Unity/Enemy%20Scripts/Character%20Controller/","title":"Character Controller","text":"<p>The setting used for the enemy is shown in this screenshot.</p> <p></p> <p>The character layer is excluded to avoid the enemies objects from self interacting.</p> <p>More information about the character controller can be found here</p>"},{"location":"Unity/Enemy%20Scripts/Child%20Collision%20Handler/","title":"Child Collision Handler","text":""},{"location":"Unity/Enemy%20Scripts/Child%20Collision%20Handler/#summary","title":"Summary","text":"<p>The <code>ChildCollisionHandler</code> is an effective way to handle collisions for parts of a composite object (like an enemy) where individual components may not need to process collisions independently, but rather report them to a central handler. This setup simplifies the management of complex interactions by encapsulating collision handling logic within the parent object, reducing redundancy and maintaining cleaner code architecture.</p>"},{"location":"Unity/Enemy%20Scripts/Child%20Collision%20Handler/#childcollisionhandler-class-explanation","title":"<code>ChildCollisionHandler</code> Class Explanation","text":""},{"location":"Unity/Enemy%20Scripts/Child%20Collision%20Handler/#overview","title":"Overview","text":"<p>The <code>ChildCollisionHandler</code> script is used to detect collisions on child components of an enemy object and pass these collision events up to a parent handler object, specifically an <code>EnemyCollisionHandler</code>. This approach is common in game development where a complex object like an enemy has multiple collidable child components that need centralized handling.</p>"},{"location":"Unity/Enemy%20Scripts/Child%20Collision%20Handler/#namespace","title":"Namespace","text":"<pre><code>using UnityEngine;\n</code></pre> <ul> <li><code>UnityEngine</code>: Provides classes and methods necessary for scripting in Unity, including components, game objects, and system events like collisions.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Child%20Collision%20Handler/#class-definition","title":"Class Definition","text":"<pre><code>public class ChildCollisionHandler : MonoBehaviour\n</code></pre> <ul> <li><code>public class ChildCollisionHandler</code>: Declares a public class named <code>ChildCollisionHandler</code>.</li> <li><code>: MonoBehaviour</code>: Indicates that <code>ChildCollisionHandler</code> inherits from <code>MonoBehaviour</code>, allowing it to be attached to GameObjects and utilize Unity's event system.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Child%20Collision%20Handler/#fields","title":"Fields","text":"<ul> <li><code>private EnemyCollisionHandler parentHandler;</code>: A private field that stores a reference to the <code>EnemyCollisionHandler</code>. This reference is used to pass collision information from the child to the parent.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Child%20Collision%20Handler/#methods","title":"Methods","text":""},{"location":"Unity/Enemy%20Scripts/Child%20Collision%20Handler/#start-method","title":"<code>Start</code> Method","text":"<pre><code>void Start()\n{\n    // Get the parent handler\n    parentHandler = GetComponentInParent&lt;EnemyCollisionHandler&gt;();\n}\n</code></pre> <ul> <li>Purpose: Called before the first frame update, this method initializes the <code>parentHandler</code> by finding the <code>EnemyCollisionHandler</code> component on the parent GameObject. This setup ensures that any collision on the child is managed by a centralized handler on the parent.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Child%20Collision%20Handler/#oncollisionenter-method","title":"<code>OnCollisionEnter</code> Method","text":"<pre><code>void OnCollisionEnter(Collision collision)\n{\n    // Relay the collision to the parent handler\n    if (parentHandler != null)\n    {\n        parentHandler.HandleChildCollision(collision);\n    }\n}\n</code></pre> <ul> <li>Purpose: Automatically called by Unity when the GameObject this script is attached to collides with another GameObject.</li> <li>Functionality:<ul> <li>Relaying Collision: If <code>parentHandler</code> is not null (i.e., it has been successfully linked in <code>Start</code>), the collision event is forwarded to the parent handler via the <code>HandleChildCollision</code> method. This allows for centralized processing of collisions at the parent level, maintaining consistency in how collisions are handled and possibly aggregating collision data or responses, such as playing a sound, changing health, or triggering animations.</li> </ul> </li> </ul>"},{"location":"Unity/Enemy%20Scripts/Enemy%20Collision%20Handler/","title":"Enemy Collision Handler","text":""},{"location":"Unity/Enemy%20Scripts/Enemy%20Collision%20Handler/#summary","title":"Summary","text":"<p>The <code>EnemyCollisionHandler</code> class provides a robust mechanism for detecting and handling critical collisions for enemy characters. By delegating collision handling to this dedicated class, the game can maintain clean separation of concerns where enemy logic is centralized, enhancing maintainability and scalability of the game code.</p>"},{"location":"Unity/Enemy%20Scripts/Enemy%20Collision%20Handler/#enemycollisionhandler-class-explanation","title":"<code>EnemyCollisionHandler</code> Class Explanation","text":""},{"location":"Unity/Enemy%20Scripts/Enemy%20Collision%20Handler/#namespace","title":"Namespace","text":"<pre><code>using UnityEngine;\n</code></pre> <ul> <li><code>UnityEngine</code>: Provides classes and methods necessary for scripting in Unity, encompassing a broad range of functionalities like game objects, components, and collision handling.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Enemy%20Collision%20Handler/#class-definition","title":"Class Definition","text":"<pre><code>public class EnemyCollisionHandler : MonoBehaviour\n</code></pre> <ul> <li><code>public class EnemyCollisionHandler</code>: Declares a public class named <code>EnemyCollisionHandler</code>.</li> <li><code>: MonoBehaviour</code>: Inherits from <code>MonoBehaviour</code>, enabling this class to be attached to Unity GameObjects and use Unity's event-driven methods such as <code>Start</code> and collision events.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Enemy%20Collision%20Handler/#fields","title":"Fields","text":"<ul> <li><code>private ToggleEnemy enemyManager;</code>: A private field storing a reference to the <code>ToggleEnemy</code> class, which is responsible for overall enemy management within the game, including tracking the number of enemies killed and managing their states.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Enemy%20Collision%20Handler/#methods","title":"Methods","text":""},{"location":"Unity/Enemy%20Scripts/Enemy%20Collision%20Handler/#start-method","title":"<code>Start</code> Method","text":"<pre><code>void Start()\n{\n    // Find the Enemy script that manages the list\n    enemyManager = FindObjectOfType&lt;ToggleEnemy&gt;();\n}\n</code></pre> <ul> <li>Purpose: Initializes the <code>enemyManager</code> by finding an active instance of the <code>ToggleEnemy</code> component somewhere within the scene. This approach assumes that there is only one <code>ToggleEnemy</code> manager active at any time, which centralizes enemy control.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Enemy%20Collision%20Handler/#handlechildcollision-method","title":"<code>HandleChildCollision</code> Method","text":"<pre><code>public void HandleChildCollision(Collision collision)\n{\n    // Check if the collided object has the tag \"Destroy\"\n    if (collision.gameObject.CompareTag(\"Destroy\") &amp;&amp; gameObject.GetComponent&lt;EnemyState&gt;().isAlive)\n    {\n        gameObject.GetComponent&lt;EnemyState&gt;().isAlive = false;\n        enemyManager.EnterRagdollState(gameObject);\n        enemyManager.EnemyKilled();\n    }\n}\n</code></pre> <ul> <li> <p>Purpose: Handles collisions reported by child components of the enemy GameObject. It specifically responds to collisions with objects tagged as \"Destroy\", indicating a collision that should result in the enemy's defeat or destruction.</p> </li> <li> <p>Functionality:</p> <ul> <li>Collision Check: First, it confirms if the colliding object is tagged with \"Destroy\" and checks if the enemy is currently alive using a <code>isAlive</code> flag from the <code>EnemyState</code> component.</li> <li>State Update: If the conditions are met, it sets the <code>isAlive</code> flag to <code>false</code>, indicating the enemy is no longer alive.</li> <li>Ragdoll Transition: Calls <code>EnterRagdollState</code> on the <code>enemyManager</code> to transition the enemy's state visually and physically to a ragdoll, enhancing the realism of the impact.</li> <li>Count Update: Invokes <code>EnemyKilled</code> on the <code>enemyManager</code> to increment the count of enemies killed, which could potentially trigger game logic such as updating scores or progressing game stages.</li> </ul> </li> </ul>"},{"location":"Unity/Enemy%20Scripts/Enemy%20State/","title":"Enemy State","text":""},{"location":"Unity/Enemy%20Scripts/Enemy%20State/#summary","title":"Summary","text":"<p>The <code>EnemyState</code> class serves as a minimalistic approach to managing the life status of enemies in a game. By toggling the <code>isAlive</code> property, other scripts can check this status to make decisions or trigger events, such as disabling enemy AI, playing a death animation, or removing the enemy from the game. This class acts as a flag for the enemy's state without implementing detailed logic itself.</p>"},{"location":"Unity/Enemy%20Scripts/Enemy%20State/#enemystate-class-explanation","title":"<code>EnemyState</code> Class Explanation","text":""},{"location":"Unity/Enemy%20Scripts/Enemy%20State/#namespace","title":"Namespace","text":"<pre><code>using System;\nusing UnityEngine;\n</code></pre> <ul> <li><code>System</code>: Used for fundamental system operations. In this context, it primarily supports basic data types like <code>Boolean</code>.</li> <li><code>UnityEngine</code>: Essential for accessing Unity-specific functionalities, enabling the script to be attached to GameObjects and manipulated within the Unity Editor.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Enemy%20State/#class-definition","title":"Class Definition","text":"<pre><code>public class EnemyState : MonoBehaviour\n</code></pre> <ul> <li><code>public class EnemyState</code>: Declares a public class named <code>EnemyState</code>.</li> <li><code>: MonoBehaviour</code>: Indicates that <code>EnemyState</code> inherits from <code>MonoBehaviour</code>, allowing it to be attached to GameObjects and utilize Unity's event-driven architecture.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Enemy%20State/#properties","title":"Properties","text":"<ul> <li><code>public Boolean isAlive = true;</code>: A public boolean field initialized to <code>true</code>, indicating that the enemy is alive by default. This variable can be toggled to <code>false</code> to represent the enemy's death, affecting gameplay dynamics such as interactions and behaviors.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Kill%20Counter/","title":"Kill Counter","text":""},{"location":"Unity/Enemy%20Scripts/Kill%20Counter/#summary","title":"Summary","text":"<ul> <li> <p>Kill Counter UI: The <code>KillCounter</code> class is designed to update a UI text element in real-time to display the number of enemies killed, as tracked by another script (<code>ToggleEnemy</code>).</p> </li> <li> <p>Dynamic Text Update: By leveraging the <code>TextMeshProUGUI</code> component and Unity's <code>Update</code> method, the script ensures that the displayed kill count is always accurate and up-to-date.</p> </li> <li> <p>Integration with <code>ToggleEnemy</code>: This script relies on the <code>ToggleEnemy</code> class to retrieve the kill count, demonstrating how different components and scripts in Unity can interact with each other to manage game state and UI updates.</p> </li> </ul>"},{"location":"Unity/Enemy%20Scripts/Kill%20Counter/#killcounter-class-explanation","title":"<code>KillCounter</code> Class Explanation","text":""},{"location":"Unity/Enemy%20Scripts/Kill%20Counter/#namespaces","title":"Namespaces","text":"<pre><code>using UnityEngine;\nusing TMPro;\n</code></pre> <ul> <li><code>using UnityEngine;</code>: Imports the <code>UnityEngine</code> namespace, which provides access to Unity's core classes and functionalities.</li> <li><code>using TMPro;</code>: Imports the <code>TMPro</code> namespace, which is required for working with TextMeshPro, Unity's advanced text rendering system.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Kill%20Counter/#class-definition","title":"Class Definition","text":"<pre><code>public class KillCounter : MonoBehaviour\n</code></pre> <ul> <li><code>public class KillCounter</code>: Defines a class named <code>KillCounter</code>.</li> <li><code>: MonoBehaviour</code>: Inherits from <code>MonoBehaviour</code>, allowing this class to be attached to Unity GameObjects and to utilize Unity's lifecycle methods like <code>Start</code> and <code>Update</code>.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Kill%20Counter/#variables","title":"Variables","text":"<ul> <li> <p><code>private ToggleEnemy enemyManager;</code>: A private variable that holds a reference to the <code>ToggleEnemy</code> class. This class is assumed to be managing enemy-related logic, including keeping track of the kill count.</p> <ul> <li> <p><code>private</code>: The variable is private, meaning it is only accessible within the <code>KillCounter</code> class.</p> </li> <li> <p><code>ToggleEnemy</code>: The type of the variable, which is a reference to another script that presumably manages enemies and their associated data, such as kill count.</p> </li> </ul> </li> </ul>"},{"location":"Unity/Enemy%20Scripts/Kill%20Counter/#start-method","title":"<code>Start</code> Method","text":"<pre><code>void Start()\n{\n    // Find the Enemy script that manages the list\n    enemyManager = FindObjectOfType&lt;ToggleEnemy&gt;();\n}\n</code></pre> <ul> <li> <p>Purpose: The <code>Start</code> method is called once when the script is first activated. It initializes the reference to the <code>ToggleEnemy</code> script.</p> </li> <li> <p>Finding the <code>ToggleEnemy</code> Script:</p> <ul> <li><code>enemyManager = FindObjectOfType&lt;ToggleEnemy&gt;();</code>: This line of code searches the scene for a <code>ToggleEnemy</code> component and assigns it to the <code>enemyManager</code> variable. <code>FindObjectOfType</code> is a Unity method that returns the first active loaded object of the specified type it finds in the scene.</li> </ul> </li> </ul>"},{"location":"Unity/Enemy%20Scripts/Kill%20Counter/#update-method","title":"<code>Update</code> Method","text":"<pre><code>void Update()\n{\n    // Update the kill count text\n    GetComponent&lt;TextMeshProUGUI&gt;().text = $\"Kills: {enemyManager.getKillCount}\";\n}\n</code></pre> <ul> <li> <p>Purpose: The <code>Update</code> method is called once per frame. It continuously updates the displayed text to reflect the current kill count.</p> </li> <li> <p>Updating the Text:</p> <ul> <li> <p><code>GetComponent&lt;TextMeshProUGUI&gt;().text = $\"Kills: {enemyManager.getKillCount}\";</code>: This line retrieves the <code>TextMeshProUGUI</code> component attached to the same GameObject as this script and updates its <code>text</code> property to display the current kill count. The kill count is fetched from the <code>getKillCount</code> property of the <code>ToggleEnemy</code> script.</p> <ul> <li> <p><code>GetComponent&lt;TextMeshProUGUI&gt;()</code>: Retrieves the <code>TextMeshProUGUI</code> component attached to the GameObject. This component is responsible for rendering the text in the UI.</p> </li> <li> <p><code>text</code>: The property of <code>TextMeshProUGUI</code> that sets the string displayed by the text element.</p> </li> <li> <p><code>$\"Kills: {enemyManager.getKillCount}\"</code>: A C# interpolated string that constructs the text to be displayed. It shows the word \"Kills:\" followed by the current value of <code>getKillCount</code> from the <code>ToggleEnemy</code> script.</p> </li> </ul> </li> </ul> </li> </ul>"},{"location":"Unity/Enemy%20Scripts/Parent%20Rigid%20Controller/","title":"Parent Rigid Controller","text":""},{"location":"Unity/Enemy%20Scripts/Parent%20Rigid%20Controller/#summary","title":"Summary","text":"<p>The <code>ParentRigidController</code> class provides a centralized mechanism for managing the physics properties of all Rigidbody components attached to child objects of a GameObject. It simplifies physics management in Unity by allowing developers to uniformly apply settings such as gravity and kinematic states from a single parent object, making it ideal for managing complex assemblies or collective objects where consistent physics behavior is required.</p>"},{"location":"Unity/Enemy%20Scripts/Parent%20Rigid%20Controller/#parentrigidcontroller-class-explanation","title":"<code>ParentRigidController</code> Class Explanation","text":""},{"location":"Unity/Enemy%20Scripts/Parent%20Rigid%20Controller/#namespaces","title":"Namespaces","text":"<pre><code>using System;\nusing UnityEngine;\n</code></pre> <ul> <li><code>System</code>: Used here to access fundamental CLR types like <code>Boolean</code>, though its direct utilities are not explicitly used in the script.</li> <li><code>UnityEngine</code>: Essential for accessing the MonoBehaviour base class and various components like Rigidbody that interact with the Unity Engine.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Parent%20Rigid%20Controller/#class-attributes","title":"Class Attributes","text":"<pre><code>[RequireComponent(typeof(CharacterController))]\n</code></pre> <ul> <li><code>RequireComponent</code>: Ensures that a <code>CharacterController</code> component is attached to the GameObject to which this script is attached. This enforces the presence of this component, which is crucial for the operations within the script.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Parent%20Rigid%20Controller/#properties-and-fields","title":"Properties and Fields","text":"<ul> <li><code>Rigidbody[] body;</code>: Holds references to the Rigidbody components of all child objects of the parent GameObject.</li> <li><code>public bool gravity = false;</code>: Controls whether gravity is applied to the child Rigidbodies.</li> <li><code>public bool isKinematic = false;</code>: Determines if the child Rigidbodies should be kinematic, affecting how they interact with the physics engine.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Parent%20Rigid%20Controller/#methods-overview","title":"Methods Overview","text":""},{"location":"Unity/Enemy%20Scripts/Parent%20Rigid%20Controller/#start-method","title":"<code>Start</code> Method","text":"<pre><code>private void Start()\n{\n    body = GetComponentsInChildren&lt;Rigidbody&gt;();\n    foreach (Rigidbody rb in body)\n    {\n        if (rb != null)\n        {\n            rb.useGravity = gravity;\n            rb.isKinematic = isKinematic;\n        }\n    }\n}\n</code></pre> <ul> <li>Initialization: Retrieves all Rigidbody components from child objects and applies specified physics settings to each, ensuring uniform behavior across all child components.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Parent%20Rigid%20Controller/#specific-functionalities","title":"Specific Functionalities","text":""},{"location":"Unity/Enemy%20Scripts/Parent%20Rigid%20Controller/#rigidbody-configuration","title":"Rigidbody Configuration","text":"<ul> <li>Uniform Application: By iterating through each Rigidbody found in child objects, the script applies the configured settings for gravity and kinematic state uniformly, ensuring all Rigidbodies behave consistently according to the parent's configuration.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/","title":"Random Movement","text":""},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#summary","title":"Summary","text":"<p>The <code>RandomMovement</code> class provides a comprehensive suite of functionalities for handling character movement, camera control, and interactions within a game environment. It is well-suited for projects requiring detailed control over character dynamics and interactions with a game world, particularly in combination with advanced camera systems like Cinemachine.</p>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#randommovement-class-explanation","title":"<code>RandomMovement</code> Class Explanation","text":""},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#namespaces","title":"Namespaces","text":"<pre><code>using System;\nusing UnityEngine;\n</code></pre> <ul> <li><code>System</code>: Includes fundamental classes and base types.</li> <li><code>UnityEngine</code>: Provides classes and methods for interacting with the Unity Engine and its components.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#class-attributes","title":"Class Attributes","text":"<pre><code>[RequireComponent(typeof(CharacterController))]\n</code></pre> <ul> <li><code>RequireComponent</code>: Ensures that a <code>CharacterController</code> component is attached to the GameObject to which this script is also attached.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#properties-and-fields","title":"Properties and Fields","text":"<ul> <li><code>MoveSpeed</code>, <code>SprintSpeed</code>: Control the movement and sprint speeds of the character.</li> <li><code>RotationSmoothTime</code>: Defines how smoothly the character rotates to face the movement direction.</li> <li><code>SpeedChangeRate</code>: Controls the rate at which the character accelerates or decelerates.</li> <li><code>JumpHeight</code>, <code>Gravity</code>: Manage the jumping mechanics and custom gravity for the character.</li> <li><code>Grounded</code>, <code>GroundedRadius</code>, <code>GroundLayers</code>: Used to check if the character is grounded and to define the parameters for the ground check.</li> <li><code>CinemachineCameraTarget</code>, <code>TopClamp</code>, <code>BottomClamp</code>, <code>CameraAngleOverride</code>: Parameters for controlling camera behavior with Cinemachine.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#methods-overview","title":"Methods Overview","text":""},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#awake-method","title":"<code>Awake</code> Method","text":"<p>Initializes camera references and ensures critical components are set up before the game starts.</p>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#start-method","title":"<code>Start</code> Method","text":"<p>Sets initial values and configurations for movement and camera settings. This includes setting animation IDs and initializing timeout counters for actions like jumping and falling.</p>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#update-method","title":"<code>Update</code> Method","text":"<p>Main loop handling the input and movement updates:</p> <ul> <li>Executes jump and gravity logic.</li> <li>Performs ground checks.</li> <li>Manages random movement direction and updates character position and rotation based on this movement.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#lateupdate-method","title":"<code>LateUpdate</code> Method","text":"<p>Updates camera rotation after all other updates are processed, ensuring the camera's movements are smooth and follow the character accurately.</p>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#specific-functionalities","title":"Specific Functionalities","text":""},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#ground-check","title":"Ground Check","text":"<pre><code>private void GroundedCheck()\n{\n    Vector3 spherePosition = new Vector3(transform.position.x, transform.position.y - GroundedOffset, transform.position.z);\n    Grounded = Physics.CheckSphere(spherePosition, GroundedRadius, GroundLayers, QueryTriggerInteraction.Ignore);\n    if (_hasAnimator) {\n        _animator.SetBool(_animIDGrounded, Grounded);\n    }\n}\n</code></pre> <p>Checks if the character is grounded by using a sphere check at the character's feet. This method updates the <code>Grounded</code> boolean and, if an animator is available, updates the corresponding animation state.</p>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#movement-and-jumping-logic","title":"Movement and Jumping Logic","text":"<p>Combines random direction generation with jumping and gravity effects to create natural and responsive character movements. Includes handling for collision detection and avoidance based on the character's immediate environment.</p>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#camera-control","title":"Camera Control","text":"<p>Manages how the camera follows the character, allowing for limits on rotation (clamping) and adjustments via input, providing a flexible camera system suitable for various gameplay scenarios.</p>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#animation-handling","title":"Animation Handling","text":"<p>Integrates with Unity's <code>Animator</code> to control character animations based on movement, jumping, and grounding status. Animation IDs are cached for performance.</p>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#collision-and-audio-feedback","title":"Collision and Audio Feedback","text":"<p>Includes methods to play specific audio clips for footsteps and landing, enhancing the game's immersive qualities. Collision events can also trigger specific behaviors or animations.</p>"},{"location":"Unity/Enemy%20Scripts/Random%20Movement/#example-usage","title":"Example Usage","text":"<p>This class can be attached to any character GameObject intended to move randomly within a scene, suitable for NPCs or interactive characters in a game environment. It requires a <code>CharacterController</code> and optionally works with <code>Cinemachine</code> for camera management.</p>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/","title":"Toggle Enemy","text":""},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#summary","title":"Summary","text":"<ul> <li>Instantiation and Removal: Handles spawning and removing enemy GameObjects based on various conditions.</li> <li>Spatial Awareness: Uses MRTK\u2019s spatial awareness to place enemies on mesh surfaces.</li> <li>Enemy Management: Manages the lifecycle of enemies, including spawning, tracking, and removal.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#toggleenemy-class-explanation","title":"<code>ToggleEnemy</code> Class Explanation","text":""},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#namespaces","title":"Namespaces","text":"<pre><code>using Microsoft.MixedReality.Toolkit.SpatialAwareness;\nusing Microsoft.MixedReality.Toolkit;\nusing UnityEngine;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System;\n</code></pre> <ul> <li><code>using Microsoft.MixedReality.Toolkit.SpatialAwareness;</code>: Provides access to spatial awareness features in the Microsoft Mixed Reality Toolkit (MRTK).</li> <li><code>using Microsoft.MixedReality.Toolkit;</code>: Includes core functionalities of MRTK.</li> <li><code>using UnityEngine;</code>: Provides access to Unity-specific classes and methods.</li> <li><code>using System.Linq;</code>: Provides LINQ query capabilities for data manipulation.</li> <li><code>using System.Collections.Generic;</code>: Provides access to generic collections such as <code>List</code>.</li> <li><code>using System;</code>: Provides basic data types and functions.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#class-definition","title":"Class Definition","text":"<pre><code>public class ToggleEnemy : MonoBehaviour\n</code></pre> <ul> <li><code>public</code>: Allows the class to be accessible from other scripts and Unity's Inspector.</li> <li><code>class ToggleEnemy</code>: Defines the class named <code>ToggleEnemy</code>.</li> <li><code>: MonoBehaviour</code>: Inherits from <code>MonoBehaviour</code>, allowing the script to be attached to Unity GameObjects and access Unity lifecycle methods.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#variables","title":"Variables","text":"<ul> <li><code>public GameObject EnemyPrefab;</code>: Prefab for the enemy model that will be instantiated in the scene.</li> <li><code>public Transform Player;</code>: Reference to the player GameObject for orientation and position-related calculations.</li> <li><code>public GameObject NormalIndicator;</code>: Prefab for a normal indicator (not used in the provided code).</li> <li><code>public Transform Parent;</code>: Transform to act as the parent for instantiated enemies.</li> <li><code>public int enemyTotal = 10;</code>: Total number of enemies to spawn.</li> <li><code>private IMixedRealitySpatialAwarenessMeshObserver observer;</code>: Interface for accessing spatial awareness mesh data.</li> <li><code>private int count = 0;</code>: Counter used to control the spawning frequency of enemies.</li> <li><code>private int killCount = 0;</code>: Keeps track of the number of enemies killed.</li> <li><code>public float killYBoundary = -10f;</code>: Y-axis boundary below which enemies are considered \"fallen\" and should be removed.</li> <li><code>private List&lt;GameObject&gt; numberEnemies = new List&lt;GameObject&gt;();</code>: List to keep track of active enemy GameObjects.</li> <li><code>public Boolean enemySpawn = true;</code>: Boolean flag to control whether enemies should be spawned.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#start-method","title":"<code>Start</code> Method","text":"<pre><code>void Start()\n{\n    var spatialAwarenessService = CoreServices.SpatialAwarenessSystem;\n    var dataProviderAccess = spatialAwarenessService as      IMixedRealityDataProviderAccess;\n    observer = dataProviderAccess.GetDataProvider&lt;IMixedRealitySpatialAwarenessMeshObserver&gt;(\"OpenXR Spatial Mesh Observer\");\n    if (observer == null)\n    {\n        Debug.LogError(\"Failed to get the spatial awareness mesh observer!\");\n        return;\n    }\n}\n</code></pre> <ul> <li>Purpose: Initializes the spatial awareness mesh observer.</li> <li>Spatial Awareness Service: Retrieves the spatial awareness system and accesses the mesh observer.</li> <li>Error Handling: Logs an error if the mesh observer cannot be obtained.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#update-method","title":"<code>Update</code> Method","text":"<pre><code>void Update()\n{\n    if (enemySpawn)\n    {\n        if (numberEnemies.Count &lt; enemyTotal &amp;&amp; count == 400)\n        {\n            RandomMeshNormalCheck();\n        }\n        if (count &lt; 400)\n        {\n            count++;\n        }\n        CheckFallenEnemies();\n    }\n    else\n    {\n        foreach (GameObject enemy in numberEnemies)\n        {\n            RemoveEnemy(enemy);\n        }\n    }\n}\n</code></pre> <ul> <li>Purpose: Manages enemy spawning and checks for fallen enemies.</li> <li>Enemy Spawning: Spawns enemies when the count is 400 and fewer enemies than <code>enemyTotal</code> exist.</li> <li>Enemy Removal: Removes all enemies if <code>enemySpawn</code> is <code>false</code>.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#enemyspawnon-method","title":"<code>EnemySpawnOn</code> Method","text":"<pre><code>public void EnemySpawnOn()\n{\n    enemySpawn = true;\n}\n</code></pre> <ul> <li>Purpose: Enables enemy spawning by setting <code>enemySpawn</code> to <code>true</code>.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#enemyspawnoff-method","title":"<code>EnemySpawnOff</code> Method","text":"<pre><code>public void EnemySpawnOn()\n{\n    enemySpawn = true;\n}\n</code></pre> <ul> <li>Purpose: Disables enemy spawning by setting <code>enemySpawn</code> to <code>false</code>.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#randommeshnormalcheck-method","title":"<code>RandomMeshNormalCheck</code> Method","text":"<pre><code>public void RandomMeshNormalCheck()\n{\n    var meshes = observer.Meshes.Values;\n    if (!meshes.Any())\n    {\n        Debug.LogWarning(\"No meshes available from the observer.\");\n        return;\n    }\n\n    int randomMeshIndex = UnityEngine.Random.Range(0, meshes.Count());\n    var randomMeshObject = meshes.ElementAt(randomMeshIndex);\n\n    if (randomMeshObject.Filter == null)\n    {\n        Debug.LogWarning(\"Mesh filter is null for the selected mesh object.\");\n        return;\n    }\n\n    Mesh mesh = randomMeshObject.Filter.sharedMesh;\n    if (mesh == null)\n    {\n        Debug.LogWarning(\"Mesh is null for the selected mesh object.\");\n        return;\n    }\n\n    Vector3[] vertices = mesh.vertices;\n    Vector3[] normals = mesh.normals;\n\n    if (vertices.Length == 0 || normals.Length == 0)\n    {\n        Debug.LogWarning($\"No vertices ({vertices.Length}) or normals ({normals.Length}) available in the selected mesh.\");\n        return;\n    }\n\n    List&lt;int&gt; floor = new List&lt;int&gt;();\n    for (int i = 0; i &lt; normals.Length; i++)\n    {\n        if (normals[i].y &gt; 0.9 &amp;&amp; vertices[i].y &lt; Player.transform.position.y + 0.2)\n        {\n            floor.Add(i);\n        }\n    }\n    if (floor.Count == 0)\n    {\n        Debug.LogWarning(\"No floor normals found in the selected mesh.\");\n        return;\n    }\n\n    int randomIndex = floor[UnityEngine.Random.Range(0, floor.Count)];\n    Vector3 randomPosition = vertices[randomIndex];\n\n    Vector3 worldPosition = randomMeshObject.Filter.transform.TransformPoint(randomPosition);\n    Vector3 offSetWorldPosition = new Vector3(worldPosition.x, worldPosition.y + 0.5f, worldPosition.z);\n    GameObject enemyInstance = Instantiate(EnemyPrefab, offSetWorldPosition, transform.rotation, Parent);\n    numberEnemies.Add(enemyInstance);\n}\n</code></pre> <ul> <li>Purpose: Spawns enemies at random positions on the floor of randomly selected meshes.</li> <li>Mesh Selection: Chooses a random mesh from available meshes.</li> <li>Position Calculation: Finds valid floor positions based on mesh normals and vertices.</li> <li>Instantiation: Creates and positions the enemy GameObject in the scene.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#removeenemy-method","title":"<code>RemoveEnemy</code> Method","text":"<pre><code>public void RemoveEnemy(GameObject enemy)\n{\n    numberEnemies.Remove(enemy);\n    Destroy(enemy);\n}\n</code></pre> <ul> <li>Purpose: Removes an enemy from the list and destroys the GameObject.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#enterragdollstate-method","title":"<code>EnterRagdollState</code> Method","text":"<pre><code>public void EnterRagdollState(GameObject enemy)\n{\n    Animator animator = enemy.GetComponent&lt;Animator&gt;();\n    StarterAssets.RandomMovement randomMovement = enemy.GetComponent&lt;StarterAssets.RandomMovement&gt;();\n\n    animator.enabled = false;\n    randomMovement.enabled = false;\n    StartCoroutine(DestroyAfterDelay(enemy, 5f));\n}\n</code></pre> <ul> <li>Purpose: Switches an enemy to a ragdoll state by disabling its <code>Animator</code> and movement scripts, then schedules destruction.</li> <li>Ragdoll Effect: Disables components to simulate ragdoll physics.</li> <li>Destruction: Calls <code>DestroyAfterDelay</code> coroutine to remove the enemy after a delay.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#destroyafterdelay-method","title":"<code>DestroyAfterDelay</code> Method","text":"<pre><code>private System.Collections.IEnumerator DestroyAfterDelay(GameObject enemy, float delay)\n{\n    yield return new WaitForSeconds(delay);\n    RemoveEnemy(enemy);\n}\n</code></pre> <ul> <li>Purpose: Coroutine to wait for a specified delay before removing the enemy from the scene.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#enemykilled-method","title":"<code>EnemyKilled</code> Method","text":"<pre><code>public void EnemyKilled()\n{\n    killCount++;\n}\n</code></pre> <ul> <li>Purpose: Increments the kill count when an enemy is killed.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#getkillcount-property","title":"<code>getKillCount</code> Property","text":"<pre><code>public int getKillCount\n{\n    get { return killCount; }\n}\n</code></pre> <ul> <li>Purpose: Provides read-only access to the current kill count.</li> </ul>"},{"location":"Unity/Enemy%20Scripts/Toggle%20Enemy/#checkfallenenemies-method","title":"<code>CheckFallenEnemies</code> Method","text":"<pre><code>private void CheckFallenEnemies()\n{\n    for (int i = numberEnemies.Count - 1; i &gt;= 0; i--)\n    {\n        if (numberEnemies[i].transform.position.y &lt; killYBoundary)\n        {\n            RemoveEnemy(numberEnemies[i]);\n        }\n    }\n}\n</code></pre> <ul> <li>Purpose: Checks if any enemies have fallen below a certain Y-axis boundary and removes them if necessary.</li> </ul>"},{"location":"Unity/Misc%20Scripts/Destroy/","title":"Destroy","text":""},{"location":"Unity/Misc%20Scripts/Destroy/#summary","title":"Summary","text":"<ul> <li> <p>Automatic Destruction: The <code>Destroy</code> class is a simple script designed to automatically destroy a GameObject after a set amount of time. This can be useful in scenarios such as temporary effects, debris, or any object that should only exist for a limited time.</p> </li> <li> <p>Customizable Timing: By making the <code>time</code> variable public, the script allows for easy adjustment of the destruction delay in the Unity Inspector, making it flexible for different use cases.</p> </li> <li> <p>Efficient Memory Management: Destroying GameObjects when they are no longer needed helps manage memory and prevent unnecessary objects from lingering in the scene, which could otherwise impact performance.</p> </li> </ul>"},{"location":"Unity/Misc%20Scripts/Destroy/#destroy-class-explanation","title":"<code>Destroy</code> Class Explanation","text":""},{"location":"Unity/Misc%20Scripts/Destroy/#namespaces","title":"Namespaces","text":"<ul> <li><code>using UnityEngine;</code>: Imports the <code>UnityEngine</code> namespace, which provides access to Unity's core classes and functionalities, such as <code>MonoBehaviour</code>, <code>GameObject</code>, and the <code>Destroy</code> method.</li> </ul>"},{"location":"Unity/Misc%20Scripts/Destroy/#class-definition","title":"Class Definition","text":"<pre><code>public class Destroy : MonoBehaviour\n</code></pre> <ul> <li><code>public class Destroy</code>: Defines a class named <code>Destroy</code>.</li> <li><code>: MonoBehaviour</code>: Inherits from <code>MonoBehaviour</code>, which allows this class to be attached to Unity GameObjects and to utilize Unity's lifecycle methods like <code>Start</code>.</li> </ul>"},{"location":"Unity/Misc%20Scripts/Destroy/#variables","title":"Variables","text":"<ul> <li> <p><code>public float time = 10f;</code>: A public variable of type <code>float</code> that determines how long (in seconds) the GameObject will exist before being destroyed. This value is set to <code>10f</code> by default, meaning the GameObject will be destroyed 10 seconds after the script starts.</p> <ul> <li> <p><code>public</code>: The variable is public, allowing it to be modified directly in the Unity Inspector. This makes the script flexible, as you can easily adjust the time to destroy the GameObject without modifying the code.</p> </li> <li> <p><code>float</code>: The type of the variable, representing a floating-point number. This is suitable for representing time intervals in Unity.</p> </li> <li> <p><code>= 10f;</code>: The default value assigned to <code>time</code>. If not modified in the Inspector, the GameObject will be destroyed after 10 seconds.</p> </li> </ul> </li> </ul>"},{"location":"Unity/Misc%20Scripts/Destroy/#start-method","title":"<code>Start</code> Method","text":"<pre><code>void Start()\n{\n    Destroy(gameObject, time);\n}\n</code></pre> <ul> <li> <p>Purpose: The <code>Start</code> method is called once when the script is first activated. In this method, the script schedules the destruction of the GameObject it is attached to.</p> </li> <li> <p>Destruction Scheduling:</p> <ul> <li> <p><code>Destroy(gameObject, time);</code>: This line of code destroys the <code>GameObject</code> to which this script is attached after a delay specified by the <code>time</code> variable. The <code>gameObject</code> refers to the object that this script component is part of.</p> <ul> <li> <p><code>Destroy</code>: A Unity method that is used to destroy objects in the scene. When a GameObject is destroyed, it is removed from the scene and all references to it are nullified.</p> </li> <li> <p><code>gameObject</code>: Refers to the GameObject to which this script is attached.</p> </li> <li> <p><code>time</code>: The delay (in seconds) before the GameObject is destroyed. The value of <code>time</code> is taken from the public variable, allowing customization via the Inspector.</p> </li> </ul> </li> </ul> </li> </ul>"},{"location":"Unity/Pistol/Bullet/","title":"Bullet","text":""},{"location":"Unity/Pistol/Bullet/#summary","title":"Summary","text":"<p>The <code>Bullet</code> class automates the firing of projectiles in a periodic manner, managing both the instantiation of the projectiles and visual indicators. This setup is useful for game objects intended to act as turrets or guns, providing a consistent mechanism for shooting mechanics.</p>"},{"location":"Unity/Pistol/Bullet/#bullet-class-explanation","title":"<code>Bullet</code> Class Explanation","text":""},{"location":"Unity/Pistol/Bullet/#namespace","title":"Namespace","text":"<pre><code>using UnityEngine;\n</code></pre> <p><code>UnityEngine</code>: Essential for accessing Unity-specific functionalities such as GameObject manipulation and component handling.</p>"},{"location":"Unity/Pistol/Bullet/#class-definition","title":"Class Definition","text":"<pre><code>public class Bullet : MonoBehaviour\n</code></pre> <ul> <li><code>public class Bullet</code>: Declares a public class named <code>Bullet</code>.</li> <li><code>: MonoBehaviour</code>: Indicates that <code>Bullet</code> inherits from <code>MonoBehaviour</code>, enabling it to be attached to GameObjects and use Unity's lifecycle methods like <code>Start</code> and <code>Update</code>.</li> </ul>"},{"location":"Unity/Pistol/Bullet/#properties-and-fields","title":"Properties and Fields","text":"<ul> <li><code>public GameObject indicator;</code>: Prefab for the indicator that appears when the bullet is shot.</li> <li><code>public Rigidbody ammo;</code>: Prefab for the projectile that will be instantiated and shot.</li> <li><code>private int count = 0;</code>: Counter to manage the timing of shots.</li> <li><code>public Transform attached;</code>: Transform component of the GameObject to which the script is attached, used for positioning the shots.</li> <li><code>public float var = 1.0f;</code>: A public float variable, possibly intended for further customization or scaling factors, but not used in the provided snippet.</li> </ul>"},{"location":"Unity/Pistol/Bullet/#methods","title":"Methods","text":""},{"location":"Unity/Pistol/Bullet/#start-method","title":"<code>Start</code> Method","text":"<pre><code>private void Start()\n{\n    attached = GetComponent&lt;Transform&gt;();\n}\n</code></pre> <ul> <li>Purpose: Initializes the <code>attached</code> variable by fetching the <code>Transform</code> component of the GameObject to which this script is attached. This setup is redundant since every GameObject inherently has a <code>Transform</code> component accessible through the <code>transform</code> property.</li> </ul>"},{"location":"Unity/Pistol/Bullet/#update-method","title":"<code>Update</code> Method","text":"<pre><code>void Update()\n{\n    if (count == 20)\n    {\n        ShootProj();\n        count = 0;\n    }\n    else\n    {\n        count++;\n    }\n}\n</code></pre> <ul> <li>Purpose: Called once per frame, this method increments the <code>count</code> and triggers <code>ShootProj()</code> every 20 frames, resetting the counter afterwards.</li> </ul>"},{"location":"Unity/Pistol/Bullet/#shootproj-method","title":"<code>ShootProj</code> Method","text":"<pre><code>private void ShootProj()\n{\n    Instantiate(ammo, attached.position + attached.forward * 0.1f, attached.rotation * Quaternion.Euler(0, 90, 90)).velocity = attached.forward * 100.0f;\n    Instantiate(indicator, attached.position + attached.forward * 10f, attached.rotation);\n}\n</code></pre> <p>Functionality:</p> <ul> <li>Projectile Instantiation: Instantiates the <code>ammo</code> prefab slightly in front of the <code>attached</code> GameObject's position, with a modified rotation to account for the intended projectile orientation. The projectile's velocity is set to move forward rapidly.</li> <li>Indicator Instantiation: Instantiates an <code>indicator</code> object 10 units in front of the <code>attached</code> GameObject, aligned with its rotation, to visually indicate the direction or impact point of the projectile.</li> </ul>"},{"location":"Unity/Pistol/Toggle%20Pistol/","title":"Toggle Pistol","text":"<p>In unity the name of the UI button is toggle pistol and the script attached is called ToggleGun.</p>"},{"location":"Unity/Pistol/Toggle%20Pistol/#summary","title":"Summary","text":"<ul> <li>Gun Instantiation and Destruction: The <code>ToggleGun</code> class provides simple functionality to instantiate a gun when needed (<code>OnGun</code>) and destroy it when no longer required (<code>OffGun</code>).</li> <li>Flexible Usage: This class can be easily attached to any GameObject in Unity, making it versatile for various scenarios, such as enabling and disabling weapons in a game.</li> <li>Prefab Handling: The class uses prefabs, which are templates for GameObjects, allowing for efficient reuse and consistent instantiation.</li> </ul>"},{"location":"Unity/Pistol/Toggle%20Pistol/#togglegun-class-explanation","title":"<code>ToggleGun</code> Class Explanation","text":""},{"location":"Unity/Pistol/Toggle%20Pistol/#namespaces","title":"Namespaces","text":"<ul> <li><code>using UnityEngine;</code>: Provides access to Unity's core classes and functionalities, enabling the script to interact with GameObjects and manage their lifecycle.</li> </ul>"},{"location":"Unity/Pistol/Toggle%20Pistol/#class-definition","title":"Class Definition","text":"<pre><code>public class ToggleGun : MonoBehaviour\n</code></pre> <ul> <li><code>public class ToggleGun</code>: Defines a class named <code>ToggleGun</code>.</li> <li><code>: MonoBehaviour</code>: Inherits from <code>MonoBehaviour</code>, allowing this class to be attached to Unity GameObjects and to utilize Unity's lifecycle methods such as <code>Start</code> and <code>Update</code>.</li> </ul>"},{"location":"Unity/Pistol/Toggle%20Pistol/#variables","title":"Variables","text":"<ul> <li><code>public GameObject GunPrefab;</code>: A public variable that stores a reference to the gun prefab. This prefab is the model or object that will be instantiated in the scene when the gun is \"turned on.\"</li> <li><code>private GameObject Gun;</code>: A private variable to hold a reference to the instantiated gun object. This allows the script to keep track of the gun instance for later manipulation or destruction.</li> </ul>"},{"location":"Unity/Pistol/Toggle%20Pistol/#ongun-method","title":"<code>OnGun</code> Method","text":"<pre><code>public void OnGun()\n{\n    Gun = Instantiate(GunPrefab, transform.position, Quaternion.identity);\n}\n</code></pre> <ul> <li> <p>Purpose: The <code>OnGun</code> method is responsible for \"turning on\" the gun by creating (instantiating) it in the scene.</p> </li> <li> <p>Instantiation:</p> <ul> <li><code>Instantiate(GunPrefab, transform.position, Quaternion.identity);</code>: This line creates a new instance of the <code>GunPrefab</code> at the current position of the GameObject to which this script is attached. The rotation is set to <code>Quaternion.identity</code>, meaning the gun will have no initial rotation (aligned with the world axes).</li> <li> <p>Reference Storage:</p> </li> <li> <p>The newly created gun instance is stored in the <code>Gun</code> variable. This allows the script to reference this specific instance later, particularly for destroying it when \"turning off\" the gun.</p> </li> </ul> </li> </ul>"},{"location":"Unity/Pistol/Toggle%20Pistol/#offgun-method","title":"<code>OffGun</code> Method","text":"<pre><code>public void OffGun()\n{\n    Destroy(Gun);\n}\n</code></pre> <ul> <li> <p>Purpose: The <code>OffGun</code> method \"turns off\" the gun by destroying the previously instantiated gun object.</p> </li> <li> <p>Destruction:</p> <ul> <li><code>Destroy(Gun);</code>: This line removes the gun instance from the scene. If the gun is currently active (i.e., it has been instantiated by the <code>OnGun</code> method), this will delete it and free up the associated resources.</li> <li> <p>Null Handling:</p> </li> <li> <p>The script does not explicitly handle cases where <code>Gun</code> might be <code>null</code> (e.g., if <code>OffGun</code> is called before <code>OnGun</code>). If <code>Gun</code> is <code>null</code>, the <code>Destroy</code> method will simply have no effect.</p> </li> </ul> </li> </ul>"},{"location":"Unity/UI/Create%20Box/","title":"Create Box","text":""},{"location":"Unity/UI/Create%20Box/#summary","title":"Summary","text":"<ul> <li> <p>Box Management: The <code>CreateBox</code> class handles the creation and management of boxes in a Unity scene. It allows for dynamically adding new boxes and automatically cleans up those that fall below a certain threshold.</p> </li> <li> <p>Prefab and Physics Integration: By using a <code>Rigidbody</code> prefab, the class ensures that instantiated boxes interact with Unity's physics system, making the simulation more realistic.</p> </li> <li> <p>Efficient Memory Management: The script efficiently manages memory by cleaning up fallen boxes, preventing them from accumulating and potentially causing performance issues.</p> </li> </ul>"},{"location":"Unity/UI/Create%20Box/#createbox-class-explanation","title":"<code>CreateBox</code> Class Explanation","text":""},{"location":"Unity/UI/Create%20Box/#namespaces","title":"Namespaces","text":"<ul> <li><code>using System.Collections.Generic;</code>: Imports the <code>System.Collections.Generic</code> namespace, which provides access to generic collection types, such as <code>List</code>.</li> <li><code>using UnityEngine;</code>: Imports the <code>UnityEngine</code> namespace, allowing access to Unity-specific classes and methods, such as <code>MonoBehaviour</code>, <code>Rigidbody</code>, and <code>GameObject</code>.</li> </ul>"},{"location":"Unity/UI/Create%20Box/#class-definition","title":"Class Definition","text":"<pre><code>public class CreateBox : MonoBehaviour\n</code></pre> <ul> <li><code>public class CreateBox</code>: Defines a class named <code>CreateBox</code>.</li> <li><code>: MonoBehaviour</code>: Inherits from <code>MonoBehaviour</code>, allowing this class to be attached to Unity GameObjects and to utilize Unity's lifecycle methods like <code>Start</code>, <code>Update</code>, and custom methods.</li> </ul>"},{"location":"Unity/UI/Create%20Box/#variables","title":"Variables","text":"<ul> <li> <p><code>public Rigidbody box;</code>: A public variable that holds a reference to a <code>Rigidbody</code> prefab. This prefab represents the box that will be instantiated in the scene. The <code>Rigidbody</code> component ensures the instantiated object will interact with Unity's physics system.</p> </li> <li> <p><code>public GameObject location;</code>: A public variable that holds a reference to a <code>GameObject</code>. This <code>GameObject</code> represents the location where the box will be instantiated. Its position will determine where the box appears in the scene.</p> </li> <li> <p><code>private List&lt;Rigidbody&gt; list = new List&lt;Rigidbody&gt;();</code>: A private variable that holds a <code>List</code> of <code>Rigidbody</code> objects. This list keeps track of all the instantiated boxes, allowing the script to manage them, such as checking their positions or destroying them when necessary.</p> </li> </ul>"},{"location":"Unity/UI/Create%20Box/#makebox-method","title":"<code>MakeBox</code> Method","text":"<pre><code>public void MakeBox()\n{\n    // Instantiate a new box at the location's position with the object's rotation\n    Rigidbody newBox = Instantiate(box, location.transform.position, transform.rotation);\n\n    // Add the new box to the list for tracking\n    list.Add(newBox);\n}\n</code></pre> <ul> <li> <p>Purpose: This method creates a new instance of the box at a specified location and adds it to the list of tracked boxes.</p> </li> <li> <p>Instantiation:</p> <ul> <li><code>Instantiate(box, location.transform.position, transform.rotation);</code>: This line creates a new instance of the <code>box</code> prefab at the position of the <code>location</code> GameObject, using the rotation of the <code>CreateBox</code> GameObject.</li> <li> <p>Tracking:</p> </li> <li> <p>The newly created <code>Rigidbody</code> instance (<code>newBox</code>) is added to the <code>list</code> to keep track of all instantiated boxes.</p> </li> </ul> </li> </ul>"},{"location":"Unity/UI/Create%20Box/#update-method","title":"<code>Update</code> Method","text":"<pre><code>void Update()\n{\n    // Use a temporary list to store items to be removed to avoid modifying the list during iteration\n    List&lt;Rigidbody&gt; itemsToRemove = new List&lt;Rigidbody&gt;();\n\n    // Iterate over the list of boxes\n    foreach (var item in list)\n    {\n        // Check if the box's y position is below -10\n        if (item.transform.position.y &lt; -10)\n        {\n            // Mark the box for removal\n            itemsToRemove.Add(item);\n        }\n    }\n\n    // Remove the marked boxes from the list and destroy their game objects\n    foreach (var item in itemsToRemove)\n    {\n        // Destroy the game object associated with the Rigidbody\n        Destroy(item.gameObject);\n        // Remove the Rigidbody from the list\n        list.Remove(item);\n    }\n}\n</code></pre> <ul> <li> <p>Purpose: The <code>Update</code> method is called once per frame. It checks the position of each instantiated box and removes any that fall below a certain threshold (<code>y &lt; -10</code>).</p> </li> <li> <p>Temporary List:</p> <ul> <li><code>List&lt;Rigidbody&gt; itemsToRemove = new List&lt;Rigidbody&gt;();</code>: A temporary list is created to store the boxes that need to be removed. This approach avoids modifying the original <code>list</code> while iterating over it, which could cause errors or unintended behavior.</li> <li> <p>Position Check:</p> </li> <li> <p>The script iterates through each <code>Rigidbody</code> in the <code>list</code>. If the <code>y</code> position of a box is less than <code>-10</code>, it is added to <code>itemsToRemove</code>.</p> </li> <li> <p>Removal and Destruction:</p> </li> <li> <p>After the iteration, the script goes through <code>itemsToRemove</code>, destroying each box's <code>GameObject</code> and removing the corresponding <code>Rigidbody</code> from the original <code>list</code>.</p> </li> </ul> </li> </ul>"},{"location":"Unity/UI/Create%20Grenade/","title":"Create Grenade","text":"<p>Yet developed</p>"},{"location":"Unity/UI/Empty%20Object%20Named%20Scripts/","title":"Empty Object Named Scripts","text":"<p>The Script Components attached to the Empty Object with the name \"Scripts\" are:</p> <ul> <li>Create Box</li> <li>Toggle Mesh</li> <li>Mesh Saver (InProgress)</li> <li>Toggle Enemy</li> <li>Toggle Drone</li> <li>Toggle Pistol</li> <li>Create Grenade (InProgress)</li> </ul> <p>All the Scripts are used to control the states of each object.</p>"},{"location":"Unity/UI/Mesh%20Saver/","title":"Mesh Saver","text":"<p>Yet developed</p>"},{"location":"Unity/UI/Pin%20Button/","title":"Pin Button","text":"<p>The object is used to determine the state of the pin. The state controls whether the UI is pinned or unpinned in space. Having the UI pinned results in the UI to stop following the user while unpinned follows the user.</p>"},{"location":"Unity/UI/Toggle%20Mesh/","title":"Toggle Mesh","text":""},{"location":"Unity/UI/Toggle%20Mesh/#summary","title":"Summary","text":"<ul> <li>Mesh Visibility Management: The <code>ToggleMesh</code> class provides an interface for toggling the visibility of spatial meshes in a Mixed Reality environment.</li> <li>Observer Utilization: The class leverages the <code>IMixedRealitySpatialAwarenessMeshObserver</code> to control whether meshes are visible (<code>Visible</code>) or hidden but still interactive (<code>Occlusion</code>).</li> <li>Integration with MRTK: This class is integrated with the Mixed Reality Toolkit (MRTK), making it a useful component for applications that require dynamic control over spatial awareness features.</li> </ul>"},{"location":"Unity/UI/Toggle%20Mesh/#togglemesh-class-explanation","title":"<code>ToggleMesh</code> Class Explanation","text":""},{"location":"Unity/UI/Toggle%20Mesh/#namespaces","title":"Namespaces","text":"<ul> <li><code>using UnityEngine;</code>: Provides access to Unity's core classes and functionalities.</li> <li><code>using Microsoft.MixedReality.Toolkit.SpatialAwareness;</code>: Provides access to Mixed Reality Toolkit (MRTK) spatial awareness functionalities, specifically for handling spatial meshes.</li> </ul>"},{"location":"Unity/UI/Toggle%20Mesh/#class-definition","title":"Class Definition","text":"<pre><code>public class ToggleMesh : MonoBehaviour\n</code></pre> <ul> <li><code>public class ToggleMesh</code>: Defines a class named <code>ToggleMesh</code>.</li> <li><code>: MonoBehaviour</code>: Inherits from <code>MonoBehaviour</code>, allowing this class to be attached to Unity GameObjects and to utilize Unity's lifecycle methods such as <code>Start</code> and <code>Update</code>.</li> </ul>"},{"location":"Unity/UI/Toggle%20Mesh/#variables","title":"Variables","text":"<ul> <li><code>private IMixedRealitySpatialAwarenessMeshObserver observer;</code>: A private variable of type <code>IMixedRealitySpatialAwarenessMeshObserver</code> that will hold the reference to the mesh observer. This observer is responsible for managing spatial meshes in the Mixed Reality environment.</li> </ul>"},{"location":"Unity/UI/Toggle%20Mesh/#start-method","title":"<code>Start</code> Method","text":"<pre><code>void Start()\n{\n    // Use CoreServices to quickly get access to the IMixedRealitySpatialAwarenessSystem\n    var spatialAwarenessService = Microsoft.MixedReality.Toolkit.CoreServices.SpatialAwarenessSystem;\n\n    // Cast to the IMixedRealityDataProviderAccess to get access to the data providers\n    var dataProviderAccess = spatialAwarenessService as Microsoft.MixedReality.Toolkit.IMixedRealityDataProviderAccess;\n\n    // Get the specific mesh observer by name\n    observer = dataProviderAccess.GetDataProvider&lt;IMixedRealitySpatialAwarenessMeshObserver&gt;(\"OpenXR Spatial Mesh Observer\");\n}\n</code></pre> <ul> <li> <p>Purpose: The <code>Start</code> method is called when the script is first initialized. It sets up the reference to the spatial mesh observer so that the class can control the display of spatial meshes.</p> </li> <li> <p>Accessing Spatial Awareness System:</p> <ul> <li>The <code>CoreServices.SpatialAwarenessSystem</code> is used to access the spatial awareness system provided by the MRTK.</li> <li>This service is cast to <code>IMixedRealityDataProviderAccess</code> to gain access to various data providers, including mesh observers.</li> <li> <p>Retrieving the Mesh Observer:</p> </li> <li> <p>The script retrieves the specific mesh observer named \"OpenXR Spatial Mesh Observer\". This observer manages the spatial mesh data, including how and when the meshes are displayed.</p> </li> </ul> </li> </ul>"},{"location":"Unity/UI/Toggle%20Mesh/#meshon-method","title":"<code>MeshOn</code> Method","text":"<pre><code>public void MeshOn()\n{\n    if (observer != null)\n    {\n        observer.DisplayOption = SpatialAwarenessMeshDisplayOptions.Visible;\n        /* Debug.Log(\"Mesh display turned on.\");\n           Debug.Log(observer.DisplayOption);\n           Debug.Log(observer.Name);*/\n    }\n}\n</code></pre> <ul> <li> <p>Purpose: This method turns on the visibility of the spatial meshes.</p> </li> <li> <p>Visibility Control:</p> <ul> <li>Checks if the <code>observer</code> is not null (i.e., it has been successfully retrieved).</li> <li>Sets the <code>DisplayOption</code> of the <code>observer</code> to <code>SpatialAwarenessMeshDisplayOptions.Visible</code>, making the spatial meshes visible in the Mixed Reality environment.</li> <li> <p>Optional Debugging:</p> </li> <li> <p>The commented-out <code>Debug.Log</code> statements can be used for debugging purposes to confirm that the mesh display has been turned on and to check the observer's current settings.</p> </li> </ul> </li> </ul>"},{"location":"Unity/UI/Toggle%20Mesh/#meshoff-method","title":"<code>MeshOff</code> Method","text":"<pre><code>public void MeshOff()\n{\n    if (observer != null)\n    {\n        observer.DisplayOption = SpatialAwarenessMeshDisplayOptions.Occlusion;\n        /* Debug.Log(\"Mesh display turned off.\");\n           Debug.Log(observer.DisplayOption);\n           Debug.Log(observer.Name);*/\n    }\n}\n</code></pre> <ul> <li> <p>Purpose: This method turns off the visibility of the spatial meshes by setting them to occlusion mode.</p> </li> <li> <p>Occlusion Control:</p> <ul> <li>Similar to the <code>MeshOn</code> method, this checks if the <code>observer</code> is not null.</li> <li>Sets the <code>DisplayOption</code> to <code>SpatialAwarenessMeshDisplayOptions.Occlusion</code>, which hides the spatial meshes from view but still allows them to interact with other objects (like occluding virtual objects).</li> <li> <p>Optional Debugging:</p> </li> <li> <p>The commented-out <code>Debug.Log</code> statements can be used to verify that the mesh display has been turned off and to check the observer's current settings.</p> </li> </ul> </li> </ul>"},{"location":"Unity/UI/UI/","title":"Ui","text":"<p>The UI contains allows the user to control global settings and this UI follows the user around.  - UI contains</p> <ul> <li>Create Box</li> <li>Toggle Enemy</li> <li>Toggle Drone</li> <li>Toggle Pistol</li> <li>Toggle Mesh</li> <li>Pin Button</li> </ul> <p>Each of these buttons have a script attached from Empty Object Named Scripts.</p>"}]}